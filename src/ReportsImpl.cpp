#include "ReportsImpl.h"

// converts a String of the form YYYY-MM-DD to time_t
// precondition: string is always of the form YYYY-MM-DD
// parameter[in]: date is a string of the form YYYY-MM-DD
// returns: a time_t object representing the date of the converted dateString
time_t ReportsImpl::convertStringToDate(string dateString) { 

	int delimiter1, delimiter2; // positions of the '-' in dateString

	// strings to store year mont and day of the dateString
	string year, month, day;

	// struct tm to hold year, month, and day
	struct tm date_tm = {0};

	// find positions of '-'
	delimiter1 = dateString.find('-');
	delimiter2 = dateString.find('-', delimiter1 + 1);

	// get year, month, and day
	year = dateString.substr(0, delimiter1);
	month = dateString.substr(delimiter1 + 1, delimiter2 - delimiter1 - 1);
	day = dateString.substr(delimiter2 + 1);

	// store year, month, and day into struct tm date_tm
	date_tm.tm_year = atoi(year.c_str()) - 1900; // tm_year counts from 1900
	date_tm.tm_mon = atoi(month.c_str()) - 1; // tm_mon is 0 to 11 for Jan to Dec
	date_tm.tm_mday = atoi(day.c_str()); // day of the month, ie. 1 to 31

	// convert date_tm to time_t and returned
	return mktime(&date_tm); 
}
// Finds all the receipt/invoice/return id's between and including two dates
// precondition: The table is set in a way that the first column is the ID (primary key), 
//               the date is in the form YYYY-MM-DD, all other entries are integers    
// parameter[in]: table is a Table of the type to search in
// parameter[in]: startDate is a string of the form YYYY-MM-DD representing the start of the period
// parameter[in]: endDate is  string of the form YYYY-MM-DD representing the end of the period
// returns: a string vector where each element an ID whose date is within the range
vector<string> ReportsImpl::findIDsBetweenDates (Table table, string startDate, string endDate)
	throw (DoesNotExistException) { 

		vector<string> returnVector; // vector of strings to store the vector to be returned

		string searchResult; // string to find return of search
		string currentRow; // stores current row of searchResult
		string ID; // stores ID of the current row
		string date; // stores date of the current row

		time_t dateTime; // time_t conversion of date
		time_t startDateTime = convertStringToDate(startDate); // time_t conversion of startDate string
		time_t endDateTime = convertStringToDate(endDate); // time_t conversion of endDate string

		int delimiter; // store position of delimiters

		searchResult = table->search("all", "all"); // get all entries in the table

		// get the first row of the search result
		delimiter = searchResult.find('\n');
		currentRow = searchResult.substr(0, delimiter +1 );

		// break down searchResult line by line
		// storing each removed line into current row, until searchResult is empty
		// each iteration find the date and add ID to returnVector if date between start and end dates
		while (!searchResult.empty()){

			// find the date of the current row and convert to a time_t
			delimiter = currentRow.find('-');
			if (delimiter > -1)
			{
				date = currentRow.substr(delimiter - 4, 10);
				dateTime = convertStringToDate(date);

				// if the date is between start and end dates, find the ID and add it to returnVector
				if (dateTime >= startDateTime && dateTime <= endDateTime)
				{
					delimiter = currentRow.find('|');
					ID = currentRow.substr(0, delimiter);
					returnVector.push_back(ID);
				}

				// break down the searchResult and find currentRow
				delimiter = searchResult.find('\n');
				searchResult = searchResult.substr(delimiter + 1);
				currentRow = searchResult.substr(0, delimiter + 1);
			}

		}

		delete table;

		// throw DoesNotExistException if there are no entries within date range
		if (returnVector.size() == 0)
			throw DoesNotExistException("Nothing found between " + startDate + " and " + endDate + ".");

		return returnVector; 
}

// Reports the total revenue and revenues per category as between two dates
// Calculates the total revenue and the revenue generated by each category between and including 
// two dates, startDate and endDate
// parameter[in]: startDate is a string of form "YYYY-MM-DD" representing the beginning of the period
// parameter[in]: endDate is a string of form "YYYY-MM-DD" representing the end of the period
// return: A string representing the whole report. It will display all categories, names, and revenues,
//         as well as total revenue.
// throw: DoesNotExistException if nothing is found between startDate and endDate
string ReportsImpl::totalRevenueReport(string startDate, string endDate) throw (DoesNotExistException) { 

	// Tables for searching
	Table category = new Category();
	Table product = new Product();
	Table salesSummary = new SalesSummary();
	Table sales = new Sales();

	vector<string> IDVector; //vector to store all ID's
	vector<int> categoryRevenueVector; //vector to store the revenue for each category
	vector<string> categoryIDVector; //vector to store all the category ID's
	vector<string> categoryNameVector; // vector to store all the category names

	string revenueReport = ""; // string to store the whole revenue report

	string searchResult; // string to store search results
	string currentRow; // string to store current row of a search result
	string salesSummaryResults = ""; //string to store all search results of salesSummary
	string allSalesResults = ""; // string to store all the Sales of all Receipts

	// strings to store column values
	string sales_id, quantity_sold, product_id, discount, price, category_id, category_name;

	// strings to convert xxxx.xx price into integer
	string priceBeforeDecimal, priceAfterDecimal;

	// int values of column names
	int quantityInt, discountInt, priceInt;

	// positions of delimiters
	int delimiter1, delimiter2, delimiter3, delimiter4;

	// stringstream to convert int to string
	stringstream converter;

	int totalRevenue = 0; // the sum of all the revenue of all the categories

	// throw DoesNotExistException with more specific message if there are
	// no entries between startDate and endDate
	try {
		// store all Receipt ID's in IDVector
		IDVector = findIDsBetweenDates(new Receipt(), startDate, endDate);
	}
	catch (DoesNotExistException e) {
		throw DoesNotExistException("There are no sales between " + startDate + " and " + endDate + ".");
	}

	searchResult = category->search("all","all");

	// *** find all category ID's and names and store them in their vectors
	// *** and initialze categoryRevenueVector to all 0's

	// get the first row of the search result
	delimiter1 = searchResult.find('\n');
	currentRow = searchResult.substr(0, delimiter1 + 1);

	// find all existing category names and id's by
	// breaking down searchResult line by line
	// storing each removed line into current row, until searchResult is empty
	// each iteration find the category name and id and store in their respective vectors
	// also sets the category revenue vector to all 0's
	while (!searchResult.empty()){

		// find category name and id of current row
		delimiter1 = currentRow.find('|');
		delimiter2 = currentRow.find('|', delimiter1 + 1);
		delimiter3 = currentRow.find('\n', delimiter2 + 1);
		category_id = currentRow.substr(0, delimiter1);
		category_name = currentRow.substr(delimiter2 + 1, delimiter3 - delimiter2 - 2);

		// add category name, id, and revenue to their vectors
		categoryIDVector.push_back(category_id);
		categoryNameVector.push_back(category_name);
		categoryRevenueVector.push_back(0);

		// break down the searchResult and find currentRow
		delimiter1 = searchResult.find('\n');
		searchResult = searchResult.substr(delimiter1 + 1);
		delimiter1 = searchResult.find('\n');
		currentRow = searchResult.substr(0, delimiter1 + 1);
	} // end while loop of finding all category name and ID's

	/// *** end of storing category names and ID's into vectors

	// find all the rows in SalesSummary that correspond to the receipt ID's in IDVector
	// and concatenate them into salesSummaryResults
	for (int i = 0; i < (int) IDVector.size(); i++)
		salesSummaryResults += salesSummary->search("receiptID", IDVector[i]);

	/// *** find all the sales of the receipt and concatenate the results to string allSalesResults

	// get the first row of the search result in salesSummary
	delimiter1 = salesSummaryResults.find('\n');
	currentRow = salesSummaryResults.substr(0, delimiter1 + 1);

	//  find all sales of the receipt by breaking down salesSummaryResults
	// and searching in the Sales for the sales ID of each row and concatenating
	// all results to allSalesResults
	while (!salesSummaryResults.empty()){

		// find the sales_id of the current row of salesSummaryResults
		delimiter1 = salesSummaryResults.find('|');
		sales_id = salesSummaryResults.substr(delimiter1 + 1);

		allSalesResults += sales->search("sales_id", sales_id);

		// break down the searchResult and find currentRow
		delimiter1 = salesSummaryResults.find('\n');
		salesSummaryResults = salesSummaryResults.substr(delimiter1 + 1);
		delimiter1 = salesSummaryResults.find('\n');
		currentRow = salesSummaryResults.substr(0, delimiter1 + 1);
	} // end while to break down salesSummaryResults

	/// *** end finding all the sales items

	/// *** Add all the sales items to category and total revenue


	// get the first row of the all the sales results
	delimiter1 = allSalesResults.find('\n');
	currentRow = allSalesResults.substr(0, delimiter1 + 1);

	// find all sales items in the allSalesResults by
	// breaking down allSalesResults line by line
	// then calculate the category revenue gained by that sales item
	// by looking up the price in the Product table and multiplying quantity and discount
	// then add the revenue to its respective category
	while (!allSalesResults.empty()){

		// find quantity_sold, product_id, and discount of Sales table
		delimiter1 = currentRow.find('|');
		delimiter2 = currentRow.find('|', delimiter1 + 1);
		delimiter3 = currentRow.find('|', delimiter2 + 1);
		quantity_sold = currentRow.substr(delimiter1 + 1, delimiter2 - delimiter1 - 1);
		product_id = currentRow.substr(delimiter2 + 1, delimiter3 - delimiter2 - 1);
		discount = currentRow.substr(delimiter3 + 1);

		// convert quantity and discount to integers
		quantityInt = atoi(quantity_sold.c_str());
		discountInt = atoi(discount.c_str());

		searchResult = product->search("product_id", product_id);

		// find category_id and price of product
		delimiter1 = searchResult.find('|');
		delimiter2 = searchResult.find('|', delimiter1 + 1);
		delimiter3 = searchResult.find('|', delimiter2 + 1);
		delimiter4 = searchResult.find('|', delimiter3 + 1);
		category_id = searchResult.substr(delimiter1 + 1, delimiter2 - delimiter1 - 1);
		price = searchResult.substr(delimiter4 + 1);

		// convert price to integer
		delimiter1 = price.find('.');
		priceBeforeDecimal = price.substr(0, delimiter1);
		priceAfterDecimal = price.substr(delimiter1 + 1, 2);
		// break up price and store without decimal places
		priceInt = atoi(priceBeforeDecimal.c_str()) * 100 + atoi(priceAfterDecimal.c_str()); 

		// find which category ID to add by comparing the current product's category ID
		// to all existing category ID's. Then add to revenue of respective category
		// and also add to totalRevenue
		for (int i = 0; i < (int) categoryIDVector.size(); i++)
		{
			if (category_id == categoryIDVector[i])
			{
				categoryRevenueVector[i] += priceInt * quantityInt * (100 - discountInt);
				totalRevenue += priceInt * quantityInt * (100 - discountInt);
			}
		}

		// break down the allSalesResults for all the sales items and find currentRow
		delimiter1 = allSalesResults.find('\n');
		allSalesResults = allSalesResults.substr(delimiter1 + 1);
		delimiter1 = allSalesResults.find('\n');
		currentRow = allSalesResults.substr(0, delimiter1 + 1);
	} // end while loop for finding every sales item

	// *** end adding all sales to total and category revenues

	// Prepare and formate each category and their revenues and add to the revenueReport
	for (int i = 0; i < (int) categoryIDVector.size(); i++)
	{
		converter.str("");
		converter << fixed << setprecision(2) << categoryRevenueVector[i] / 10000.0;
		revenueReport += categoryNameVector[i] + " (ID:" + categoryIDVector[i] + ") ----- $" + converter.str() + "\n";
	}

	// Prepare the total revenue for the report
	converter.str("");
	converter << fixed << setprecision(2) << totalRevenue / 10000.0;
	revenueReport += "TOTAL REVENUE ----- $" + converter.str() + "\n";

	delete category;
	delete product;
	delete salesSummary;

	return revenueReport; 
}

string ReportsImpl::reportBetweenDates(Table table, vector<string> IDs, string strColToSearch)
{
	string strSalesFound = "";
	for (int i = 0; i < IDs.size(); i++)
	{
		strSalesFound += table->search(strColToSearch, IDs[i]) + "\r\n";
	}
	return strSalesFound;
}

ReportsImpl::~ReportsImpl() {};
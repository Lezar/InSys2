#include "ReportsImpl.h"

// converts a String of the form YYYY-MM-DD to time_t
// precondition: string is always of the form YYYY-MM-DD
// parameter[in]: date is a string of the form YYYY-MM-DD
// returns: a time_t object representing the date of the converted dateString
time_t ReportsImpl::convertStringToDate(string dateString) { 

	int delimiter1, delimiter2; // positions of the '-' in dateString

	// strings to store year mont and day of the dateString
	string year, month, day;

	// struct tm to hold year, month, and day
	struct tm date_tm = {0};

	// find positions of '-'
	delimiter1 = dateString.find('-');
	delimiter2 = dateString.find('-', delimiter1 + 1);

	// get year, month, and day
	year = dateString.substr(0, delimiter1);
	month = dateString.substr(delimiter1 + 1, delimiter2 - delimiter1 - 1);
	day = dateString.substr(delimiter2 + 1);

	// store year, month, and day into struct tm date_tm
	date_tm.tm_year = atoi(year.c_str()) - 1900; // tm_year counts from 1900
	date_tm.tm_mon = atoi(month.c_str()) - 1; // tm_mon is 0 to 11 for Jan to Dec
	date_tm.tm_mday = atoi(day.c_str()); // day of the month, ie. 1 to 31

	// convert date_tm to time_t and returned
	return mktime(&date_tm); 
}
// Finds all the receipt/invoice/return id's between and including two dates
// precondition: The table is set in a way that the first column is the ID (primary key), 
//               the date is in the form YYYY-MM-DD, all other entries are integers    
// parameter[in]: table is a Table of the type to search in
// parameter[in]: startDate is a string of the form YYYY-MM-DD representing the start of the period
// parameter[in]: endDate is  string of the form YYYY-MM-DD representing the end of the period
// returns: a string vector where each element an ID whose date is within the range
vector<string> ReportsImpl::findIDsBetweenDates (Table table, string startDate, string endDate)
	throw (DoesNotExistException) { 

		vector<string> returnVector; // vector of strings to store the vector to be returned

		string searchResult; // string to find return of search
		string currentRow; // stores current row of searchResult
		string ID; // stores ID of the current row
		string date; // stores date of the current row

		time_t dateTime; // time_t conversion of date
		time_t startDateTime = convertStringToDate(startDate); // time_t conversion of startDate string
		time_t endDateTime = convertStringToDate(endDate); // time_t conversion of endDate string

		int delimiter; // store position of delimiters

		searchResult = table->search("all", "all"); // get all entries in the table

		// get the first row of the search result
		delimiter = searchResult.find('\n');
		currentRow = searchResult.substr(0, delimiter +1 );

		// break down searchResult line by line
		// storing each removed line into current row, until searchResult is empty
		// each iteration find the date and add ID to returnVector if date between start and end dates
		while (!searchResult.empty()){

			// find the date of the current row and convert to a time_t
			delimiter = currentRow.find('-');
			if (delimiter > -1)
			{
				date = currentRow.substr(delimiter - 4, 10);
				dateTime = convertStringToDate(date);

				// if the date is between start and end dates, find the ID and add it to returnVector
				if (dateTime >= startDateTime && dateTime <= endDateTime)
				{
					delimiter = currentRow.find('|');
					ID = currentRow.substr(0, delimiter);
					returnVector.push_back(ID);
				}

				// break down the searchResult and find currentRow
				delimiter = searchResult.find('\n');
				searchResult = searchResult.substr(delimiter + 1);
				currentRow = searchResult.substr(0, delimiter + 1);
			}

		}

		// throw DoesNotExistException if there are no entries within date range
		if (returnVector.size() == 0)
			throw DoesNotExistException("Nothing found between " + startDate + " and " + endDate + ".");

		return returnVector; 
}

// Reports the total revenue and revenues per category as between two dates
// Calculates the total revenue and the revenue generated by each category between and including 
// two dates, startDate and endDate
// parameter[in]: startDate is a string of form "YYYY-MM-DD" representing the beginning of the period
// parameter[in]: endDate is a string of form "YYYY-MM-DD" representing the end of the period
// return: A string representing the whole report. It will display all categories, names, and revenues,
//         as well as total revenue.
// throw: DoesNotExistException if nothing is found between startDate and endDate
string ReportsImpl::totalRevenueReport(string startDate, string endDate) throw (DoesNotExistException) { 

	// Tables for searching
	Table category = new Category();
	Table product = new Product();
	Table salesSummary = new SalesSummary();
	Table sales = new Sales();

	vector<string> IDVector; //vector to store all ID's
	vector<__int64> categoryRevenueVector; //vector to store the revenue for each category
	vector<string> categoryIDVector; //vector to store all the category ID's
	vector<string> categoryNameVector; // vector to store all the category names

	string revenueReport = ""; // string to store the whole revenue report

	string searchResult; // string to store search results
	string currentRow; // string to store current row of a search result
	string salesSummaryResults = ""; //string to store all search results of salesSummary
	string allSalesResults = ""; // string to store all the Sales of all Receipts

	// strings to store column values
	string sales_id, quantity_sold, product_id, discount, price, category_id, category_name;

	// strings to convert xxxx.xx price into integer
	string priceBeforeDecimal, priceAfterDecimal;

	// int values of column names
	__int64 quantityInt, discountInt, priceInt;

	// positions of delimiters
	int delimiter1, delimiter2, delimiter3, delimiter4;

	// stringstream to convert int to string
	stringstream converter;

	__int64 totalRevenue = 0; // the sum of all the revenue of all the categories

	Table receipt = new Receipt(); // receipt class to search all ID's

	// throw DoesNotExistException with more specific message if there are
	// no entries between startDate and endDate
	try {
		// store all Receipt ID's in IDVector
		IDVector = findIDsBetweenDates(receipt, startDate, endDate);
		delete receipt;

	}
	catch (DoesNotExistException e) {
		delete receipt;
		throw DoesNotExistException("There are no sales between " + startDate + " and " + endDate + ".");
	}

	searchResult = category->search("all","all");

	// *** find all category ID's and names and store them in their vectors
	// *** and initialze categoryRevenueVector to all 0's

	// get the first row of the search result
	delimiter1 = searchResult.find('\n');
	currentRow = searchResult.substr(0, delimiter1 + 1);

	// find all existing category names and id's by
	// breaking down searchResult line by line
	// storing each removed line into current row, until searchResult is empty
	// each iteration find the category name and id and store in their respective vectors
	// also sets the category revenue vector to all 0's
	while (!searchResult.empty()){

		// find category name and id of current row
		delimiter1 = currentRow.find('|');
		delimiter2 = currentRow.find('|', delimiter1 + 1);
		delimiter3 = currentRow.find('\n', delimiter2 + 1);
		category_id = currentRow.substr(0, delimiter1);
		category_name = currentRow.substr(delimiter2 + 1, delimiter3 - delimiter2 - 2);

		// add category name, id, and revenue to their vectors
		categoryIDVector.push_back(category_id);
		categoryNameVector.push_back(category_name);
		categoryRevenueVector.push_back(0);

		// break down the searchResult and find currentRow
		delimiter1 = searchResult.find('\n');
		searchResult = searchResult.substr(delimiter1 + 1);
		delimiter1 = searchResult.find('\n');
		currentRow = searchResult.substr(0, delimiter1 + 1);
	} // end while loop of finding all category name and ID's

	/// *** end of storing category names and ID's into vectors

	// find all the rows in SalesSummary that correspond to the receipt ID's in IDVector
	// and concatenate them into salesSummaryResults
	for (int i = 0; i < (int) IDVector.size(); i++)
		salesSummaryResults += salesSummary->search("receiptID", IDVector[i]);

	/// *** find all the sales of the receipt and concatenate the results to string allSalesResults

	// get the first row of the search result in salesSummary
	delimiter1 = salesSummaryResults.find('\n');
	currentRow = salesSummaryResults.substr(0, delimiter1 + 1);

	//  find all sales of the receipt by breaking down salesSummaryResults
	// and searching in the Sales for the sales ID of each row and concatenating
	// all results to allSalesResults
	while (!salesSummaryResults.empty()){

		// find the sales_id of the current row of salesSummaryResults
		delimiter1 = salesSummaryResults.find('|');
		sales_id = salesSummaryResults.substr(delimiter1 + 1);

		allSalesResults += sales->search("sales_id", sales_id);

		// break down the searchResult and find currentRow
		delimiter1 = salesSummaryResults.find('\n');
		salesSummaryResults = salesSummaryResults.substr(delimiter1 + 1);
		delimiter1 = salesSummaryResults.find('\n');
		currentRow = salesSummaryResults.substr(0, delimiter1 + 1);
	} // end while to break down salesSummaryResults

	/// *** end finding all the sales items

	/// *** Add all the sales items to category and total revenue


	// get the first row of the all the sales results
	delimiter1 = allSalesResults.find('\n');
	currentRow = allSalesResults.substr(0, delimiter1 + 1);

	// find all sales items in the allSalesResults by
	// breaking down allSalesResults line by line
	// then calculate the category revenue gained by that sales item
	// by looking up the price in the Product table and multiplying quantity and discount
	// then add the revenue to its respective category
	while (!allSalesResults.empty()){

		// find quantity_sold, product_id, and discount of Sales table
		delimiter1 = currentRow.find('|');
		delimiter2 = currentRow.find('|', delimiter1 + 1);
		delimiter3 = currentRow.find('|', delimiter2 + 1);
		quantity_sold = currentRow.substr(delimiter1 + 1, delimiter2 - delimiter1 - 1);
		product_id = currentRow.substr(delimiter2 + 1, delimiter3 - delimiter2 - 1);
		discount = currentRow.substr(delimiter3 + 1);

		// convert quantity and discount to integers
		quantityInt = atoi(quantity_sold.c_str());
		discountInt = atoi(discount.c_str());

		searchResult = product->search("product_id", product_id);

		// find category_id and price of product
		delimiter1 = searchResult.find('|');
		delimiter2 = searchResult.find('|', delimiter1 + 1);
		delimiter3 = searchResult.find('|', delimiter2 + 1);
		delimiter4 = searchResult.find('|', delimiter3 + 1);
		category_id = searchResult.substr(delimiter1 + 1, delimiter2 - delimiter1 - 1);
		price = searchResult.substr(delimiter4 + 1);

		// convert price to integer
		delimiter1 = price.find('.');
		priceBeforeDecimal = price.substr(0, delimiter1);
		priceAfterDecimal = price.substr(delimiter1 + 1, 2);
		// break up price and store without decimal places
		priceInt = atoi(priceBeforeDecimal.c_str()) * 100 + atoi(priceAfterDecimal.c_str()); 

		// find which category ID to add by comparing the current product's category ID
		// to all existing category ID's. Then add to revenue of respective category
		// and also add to totalRevenue
		for (int i = 0; i < (int) categoryIDVector.size(); i++)
		{
			if (category_id == categoryIDVector[i])
			{
				categoryRevenueVector[i] += priceInt * quantityInt * (100 - discountInt) * 10 + 5;
				totalRevenue += priceInt * quantityInt * (100 - discountInt) * 10 + 5;
			}
		}

		// break down the allSalesResults for all the sales items and find currentRow
		delimiter1 = allSalesResults.find('\n');
		allSalesResults = allSalesResults.substr(delimiter1 + 1);
		delimiter1 = allSalesResults.find('\n');
		currentRow = allSalesResults.substr(0, delimiter1 + 1);
	} // end while loop for finding every sales item

	// *** end adding all sales to total and category revenues

	// strings to store information for formatting
	string categoryInfo;
	string revenue;
	stringstream ssCat;
	stringstream ssRev;

	// Prepare and formate each category and their revenues and add to the revenueReport
	for (int i = 0; i < (int) categoryIDVector.size(); i++)
	{
		converter.str("");
		converter << fixed << setprecision(2) << categoryRevenueVector[i] / 100000.0;

		ssCat.str("");
		ssRev.str("");

		categoryInfo = categoryNameVector[i] + " (ID:" + categoryIDVector[i] + ")";
		ssCat << setw(40) << setiosflags(ios_base::left) << categoryInfo;
		categoryInfo = ssCat.str();

		revenue = "$" + converter.str();
		ssRev << setw(15) << setiosflags(ios_base::right) << revenue;
		revenue = ssRev.str();

		revenueReport += categoryInfo + "\t" + revenue + "\n";
	}

	string revenueTotal;
	stringstream ssRevTotal;
	// Prepare the total revenue for the report
	converter.str("");
	converter << fixed << setprecision(2) << totalRevenue / 100000.0;

	revenueTotal = "$" + converter.str();
	ssRevTotal << setw(50) << revenueTotal;
	revenueTotal = ssRevTotal.str();

	revenueReport += "TOTAL REVENUE" + revenueTotal + "\n";

	delete category;
	delete product;
	delete salesSummary;

	return revenueReport; 
}

string ReportsImpl::topSellersReport(string selectedCategory, string startDate, string endDate) 
{
	// vector to hold all the receipt ID's from between the start and end dates
	vector<string> receiptIDVect;

	// find all receipt id's between start and end dates
	Table receipt = new Receipt();
	try {
		// the vector returned by the findIDsBetweenDates function
		receiptIDVect = findIDsBetweenDates(receipt, startDate, endDate);
		delete receipt;
	}
	catch (DoesNotExistException e) {
		delete receipt;
		throw DoesNotExistException("There are no sales between " + startDate + " and " + endDate + ".");
	}


	Table salesSummaryTable = new SalesSummary();

	// vector to store the sales ID's corresponding to the receipt ID's already obtained
	vector<string> salesIDVect;

	// string to hold the result of each search in the salesSummary table
	string resultOfSearch;

	//string to hold the sale ID from the resulting row returned by the search
	string saleID;

	// initialization of delimiters
	int delimiter;
	int delimiter2;
	int delimiter3;
	int delimiter4;

	// iterates through receiptIDVect and searches for each receiptID in the sales summary table
	for(int i = 0; i < (int) receiptIDVect.size(); i++)
	{
		try{
			if(receiptIDVect[i].size() > 0)
				resultOfSearch = salesSummaryTable->search("receiptID", receiptIDVect[i]);

			// assigns the delimiter position
			delimiter = resultOfSearch.find('|');

			stringstream resultStream(resultOfSearch);
			while(getline(resultStream, saleID))
			{
				// assigns string sales ID with data in the row
				saleID = saleID.substr(delimiter+1);

				salesIDVect.push_back(saleID);
			}

		} catch (DoesNotExistException e){ break; }
	}

	delete salesSummaryTable;

	Table salesTable = new Sales();

	//string to hold the product ID from the resulting row returned by the search
	string productID;

	//string to hold the product quantity from the resulting row returned by the search
	string productQuantity;

	// vector to store the product ID's and quantity corresponding to the sales ID's already obtained
	vector<string> productVect;

	// iterates through salesIDVect and searches for each salesID in the sales table
	for(int i = 0; i < (int) salesIDVect.size(); i++)
	{
		try{
			if(salesIDVect[i].size() > 0)
				resultOfSearch = salesTable->search("sales_id", salesIDVect[i]);

			// finds the first delimiter position and assigns it to int delimiter
			delimiter = resultOfSearch.find('|');

			// finds the second delimiter position and assigns it to int delimiter2
			delimiter2 = resultOfSearch.find('|', delimiter+1);

			// finds the third delimiter position and assigns it to int delimiter3
			delimiter3 = resultOfSearch.find('|', delimiter2+1);

			// retrieves the product ID from the row data and assigns it to productID
			productID = resultOfSearch.substr(delimiter2+1,delimiter3-delimiter2-1);

			// retrieves the product quantity from the row data and assigns it to string productQuantity
			productQuantity = resultOfSearch.substr(delimiter+1, delimiter2-delimiter-1);

			productVect.push_back(productID + "|" + productQuantity);

		} catch (DoesNotExistException e){ break; }
	}

	delete salesTable;

	// vector to contain only products in the selected category
	vector<string> productsInCategoryVect;

	Table productTable = new Product();

	// string to hold the name of the product
	string productName;

	// string to hold the category the product belongs to
	string productCategory;

	// iterates through productVect and searches for each productID in the product table
	for(int i = 0; i < (int) productVect.size(); i++)
	{
		try{
			if(productVect[i].size() > 0) {
				// finds the first two delimiters positions and assign them to int delimiter and delimiter2
				delimiter = productVect[i].find('|');
				delimiter2 = productVect[i].find('|', delimiter + 1);

				productQuantity = productVect[i].substr(delimiter + 1, delimiter2 - delimiter - 1);

				productID = productVect[i].substr(0, delimiter);

				resultOfSearch = productTable->search("product_id", productID);
			}

			// finds the first delimiter position and assigns it to int delimiter
			delimiter = resultOfSearch.find('|');

			// finds the second delimiter position and assigns it to int delimiter2
			delimiter2 = resultOfSearch.find('|', delimiter+1);

			// finds the third delimiter position and assigns it to int delimiter3
			delimiter3 = resultOfSearch.find('|', delimiter2+1);

			// finds the fourth delimiter position and assigns it to int delimiter4
			delimiter4 = resultOfSearch.find('|', delimiter3+1);

			// retrieves the product name from the row data and assigns it to productName
			productName = resultOfSearch.substr(delimiter3+1,delimiter4-delimiter3-1);

			stringstream ss;

			ss << setw(40) << setfill(' ') << setiosflags(ios_base::left) << productName;

			productName = ss.str();

			// retrieves the product category from the row data and assigns it to productCategory
			productCategory = resultOfSearch.substr(delimiter+1,delimiter2-delimiter-1);

			if(productCategory == selectedCategory)
			{
				productsInCategoryVect.push_back(productID + "  -  " + productName + "Quantity Sold:" + productQuantity);
			}

		} catch (DoesNotExistException e){ break; }
	}

	delete productTable;

	// vector to hold the products with combined quantities (all sales of each product tallied up)
	vector<string> productsWithQuantities;

	// strings to temporarily store information for comparisons and quantity addition
	string tempProductID;
	string tempProductIDStored;
	string tempProductRow;
	string tempProductRowStored;
	int tempProductQuantity;
	int tempProductQuantityStored;
	string tempProductQuantityStoredString;

	// stores the position of the for loop 'j' counter
	int jPosition;

	// boolean to tell if the product already is stored in the productsWithQuantities vector
	bool productAlreadyStored = false;

	// iterates through the productsInCategoryVect vector
	for(int i = 0; i < (int) productsInCategoryVect.size(); i++)
	{
		delimiter = productsInCategoryVect[i].find(' ');
		tempProductID = productsInCategoryVect[i].substr(0,delimiter);

		// iterates through the productsWithQuantities vector checking if product is already stored
		for(int j = 0; j < (int) productsWithQuantities.size(); j++)
		{
			delimiter = productsWithQuantities[j].find(' ');

			tempProductIDStored = productsWithQuantities[j].substr(0,delimiter);

			jPosition = j;
			if (tempProductID == tempProductIDStored)
			{
				productAlreadyStored = true;
				break;
			}
		}

		// if product is already stored quantity is added to existing quantity
		// else product is stored into productsWithQuantities vector
		if (productAlreadyStored)
		{
			productAlreadyStored = false;

			tempProductRowStored = productsWithQuantities[jPosition];

			tempProductRow = productsInCategoryVect[i];

			delimiter = tempProductRow.find(':');
			tempProductQuantity = atoi(tempProductRow.substr(delimiter + 1).c_str());

			delimiter = tempProductRowStored.find(':');
			tempProductQuantityStored = atoi(tempProductRowStored.substr(delimiter + 1).c_str());

			tempProductQuantityStored += tempProductQuantity;
			stringstream stream;
			stream << tempProductQuantityStored;
			tempProductQuantityStoredString = stream.str();

			tempProductRowStored.replace(delimiter + 1, 20, tempProductQuantityStoredString);

			productsWithQuantities[jPosition] = tempProductRowStored;
		} else {
			productsWithQuantities.push_back(productsInCategoryVect[i]);
		}
	}

	Table categoryTable = new Category();

	// retrieve selected category from categoryTable
	string categoryRow = categoryTable->search("category_id", selectedCategory);

	delete categoryTable;

	// find delimiters in category row
	delimiter = categoryRow.find('|');
	delimiter2 = categoryRow.find('|', delimiter + 1);

	// get substring containing the category name to be used in the report header line
	string categoryName = categoryRow.substr(delimiter2 + 1);

	// strings to contain the retrieved row from the vector
	string currentProduct;
	string currentProductStored;

	// vector to store sorted products
	vector<string> productsSorted;

	//integers for product quantity comparison
	int quantity;
	int quantityStored;

	// loop through every entry in the productsWithQuantities vector and sort by quantity sold
	for(int x = 0; x < (int) productsWithQuantities.size(); x++)
	{
		currentProduct = productsWithQuantities[x];
		delimiter = currentProduct.find(':');
		quantity = atoi(currentProduct.substr(delimiter + 1).c_str());

		if(productsSorted.size() == 0) {
			productsSorted.push_back(currentProduct);
		} else {
			for(int i = 0; i < (int) productsSorted.size(); i++)
			{
				currentProductStored = productsSorted[i];
				delimiter = currentProductStored.find(':');
				quantityStored = atoi(currentProductStored.substr(delimiter + 1).c_str());
				if(quantity > quantityStored) {
					productsSorted.insert(productsSorted.begin() + i,productsWithQuantities[x]);
					break;
				}
			}
			if(quantity <= quantityStored)
			{
				productsSorted.push_back(productsWithQuantities[x]);
			}
		}

	}

	// string to contain the information of the report
	string report;

	// create header line for the Report
	report = "Top Selling Products Report in " + categoryName + "\r\n-------------------------------------------------------------------------------------\r\n";

	// output the first ten products in the vector into the report string
	for(int j = 0; j < (int) productsSorted.size() && j < 10; j++)
	{
		report += productsSorted[j];
		report += "\r\n";
	}

	// return report
	return report;
}

string ReportsImpl::reportBetweenDates(Table tblTableToReport, string startDate, string endDate, string strColToSearch)
{
	string strReportsFound = "";
	vector<string> IDs;

	try
	{
		IDs = findIDsBetweenDates(tblTableToReport, startDate, endDate);

		for (int i = 0; i < IDs.size(); i++)
		{

			strReportsFound += tblTableToReport->search(strColToSearch, IDs[i]) + "\r\n";
		}
	}
	catch (DoesNotExistException e) {
		throw DoesNotExistException("There are no " + strColToSearch.substr(0, strColToSearch.length() - 3) + " between " + startDate + " and " + endDate + ".");
	}



	return strReportsFound;
}

ReportsImpl::~ReportsImpl() {};